<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

</head>

<body>
    <div class="indexChanges">
        <ul id="indexChangesList">
            <!-- Index changes will be populated here -->
        </ul>
    </div>

    <header class="navbar">
        <div>
            <button id="theme-toggle" onclick="toggleTheme()">◑</button>
        </div>
    </header>

    <div class="fetch-con">
        <input class="input-field" type="text" placeholder="Enter Stock Ticker" />
        <button class="fetch-btn" onclick="fetchAndDisplayData()">
            <i class="fas fa-search"></i>
        </button>
    </div>

    <div id="stocksContainer"></div>


    </div>

    <!-- implement HTML for filter -->

    <script>
        /*
        TODO:
        - refactor the code
        - implement the filter function
            - implement the ability to set ranges for the metrics and the table should only display the stocks that meet the criteria.
        - implement minimize and maximize function for the tables
        - implement the ability to compare tables side by side
            
        */


        const apikey = '1z3Eat6B3MbUU0ayvXDBXEt4D82W1Zmo'

        let stocks = [];
        let theme = 'dark';
        let ticker = document.querySelector('.input-field').value;

        /*
            # TODO:
            - Go over what metrics we want to display in the table
            - If metric not in keyMapping object, don't display it
            - The filter should modify keyMapping in the future
        */

        const keyMapping = {
            "acceptedDate": "GodkäntDatum",
            "averageInventory": "GenomsnittligtLager",
            "averagePayables": "GenomsnittligaKortfristigaSkulder",
            "averageReceivables": "GenomsnittligaFordringar",
            "bookValuePerShare": "BokföringsvärdePerAktie",
            "calendarYear": "Kalenderår",
            "capexToDepreciation": "CapexTillAvskrivningar",
            "capexToOperatingCashFlow": "CapexTillRörelseKassaflöde",
            "capexToRevenue": "CapexTillIntäkter",
            "cashPerShare": "KontanterPerAktie",
            "cik": "CIK",
            "costAndExpenses": "KostnaderOchUtgifter",
            "costOfRevenue": "KostnadFörIntäkter",
            "currentRatio": "Kassalikviditet",
            "date": "Datum",
            "daysOfInventoryOnHand": "DagarLagerIHand",
            "daysPayablesOutstanding": "DagarBetalningarUtestående",
            "daysSalesOutstanding": "DagarFörsäljningUtestående",
            "debtToAssets": "SkulderTillTillgångar",
            "debtToEquity": "SkuldTillEgetKapital",
            "depreciationAndAmortization": "AvskrivningarOchNedskrivningar",
            "dividendYield": "Utdelningsavkastning",
            "earningsYield": "Resultatavkastning",
            "ebitda": "EBITDA",
            "ebitdaratio": "EBITDAKvot",
            "enterpriseValue": "Företagsvärde",
            "enterpriseValueOverEBITDA": "FöretagsvärdeÖverEBITDA",
            "eps": "EPS",
            "epsdiluted": "EPSUtdunnat",
            "evToFreeCashFlow": "EVtillFrittKassaflöde",
            "evToOperatingCashFlow": "EVtillRörelsekassaflöde",
            "evToSales": "EVtillFörsäljning",
            "fillingDate": "Inlämningsdatum",
            "finalLink": "SlutligLänk",
            "freeCashFlowPerShare": "FrittKassaflödePerAktie",
            "freeCashFlowYield": "FrittKassaflödeAvkastning",
            "generalAndAdministrativeExpenses": "AllmännaOchAdministrativaKostnader",
            "grahamNetNet": "GrahamNetNet",
            "grahamNumber": "GrahamTal",
            "grossProfit": "Bruttovinst",
            "grossProfitRatio": "Bruttovinstmarginal",
            "incomeBeforeTax": "ResultatFöreSkatt",
            "incomeBeforeTaxRatio": "ResultatFöreSkattKvot",
            "incomeQuality": "Inkomstkvalitet",
            "incomeTaxExpense": "Inkomstskattekostnad",
            "intangiblesToTotalAssets": "ImmateriellaTillgångarTillTotalaTillgångar",
            "interestCoverage": "Räntetäckningsgrad",
            "interestDebtPerShare": "RäntebärandeSkuldPerAktie",
            "interestExpense": "Räntekostnad",
            "interestIncome": "Ränteintäkter",
            "inventoryTurnover": "Lageromsättningshastighet",
            "investedCapital": "InvesteratKapital",
            "link": "Länk",
            "marketCap": "Marknadsvärde",
            "netCurrentAssetValue": "NettoNuvarandeTillgångsvärde",
            "netDebtToEBITDA": "NettoSkuldTillEBITDA",
            "netIncome": "Nettoinkomst",
            "netIncomePerShare": "NettoinkomstPerAktie",
            "netIncomeRatio": "NettoinkomstKvot",
            "operatingCashFlowPerShare": "RörelsekassaflödePerAktie",
            "operatingExpenses": "Rörelsekostnader",
            "operatingIncome": "Rörelseresultat",
            "operatingIncomeRatio": "RörelseresultatKvot",
            "otherExpenses": "ÖvrigaKostnader",
            "payablesTurnover": "LeverantörsskulderOmsättning",
            "payoutRatio": "Utdelningsförhållande",
            "pbRatio": "P/B-Tal",
            "peRatio": "P/E-Tal",
            "period": "Period",
            "pfcfRatio": "P/FCF-Tal",
            "pocfratio": "P/OCF-Kvot",
            "priceToSalesRatio": "PrisTillFörsäljningsKvot",
            "ptbRatio": "PTB-Kvot",
            "receivablesTurnover": "KundfordringarOmsättning",
            "reportedCurrency": "RapporteradValuta",
            "researchAndDevelopmentExpenses": "ForskningsOchUtvecklingskostnader",
            "researchAndDdevelopementToRevenue": "FoU-tillIntäkter",
            "returnOnTangibleAssets": "AvkastningPåMateriellaTillgångar",
            "revenue": "Intäkter",
            "revenuePerShare": "IntäkterPerAktie",
            "roic": "ROIC",
            "salesGeneralAndAdministrativeToRevenue": "FörsäljningAllmännaOchAdministrativaTillIntäkter",
            "sellingAndMarketingExpenses": "FörsäljningsOchMarknadsföringskostnader",
            "sellingGeneralAndAdministrativeExpenses": "FörsäljningsAllmännaOchAdministrativaKostnader",
            "shareholdersEquityPerShare": "EgetKapitalPerAktie",
            "stockBasedCompensationToRevenue": "AktiebaseradErsättningTillIntäkter",
            "symbol": "Symbol",
            "tangibleAssetValue": "MateriellaTillgångarsVärde",
            "tangibleBookValuePerShare": "MaterielltBokföringsvärdePerAktie",
            "totalOtherIncomeExpensesNet": "TotalaÖvrigaInkomsterKostnaderNetto",
            "weightedAverageShsOut": "VägtGenomsnittligtAntalAktierUte",
            "weightedAverageShsOutDil": "VägtGenomsnittligtAntalUttunnadeAktier",
            "workingCapital": "Rörelsekapital"
        };


        // THEME TOGGLE
        function checkTheme() {
            const currentTheme = localStorage.getItem('theme') || 'light';
            document.body.setAttribute('data-theme', currentTheme);
        };
        document.addEventListener('DOMContentLoaded', (event) => {
            checkTheme();
            fetchData();
        });

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        };


        // FETCH INDEX DATA
        async function fetchIndex() {
            const indexList = ['^OMXS30', '^NDX', '^SPX', '^DJSH'];
            const indexChangesList = document.getElementById('indexChangesList');
            indexChangesList.innerHTML = '';

            for (const index of indexList) {
                try {
                    const response = await fetch(`https://financialmodelingprep.com/api/v3/quote/${index}?apikey=${apikey}`);
                    const data = await response.json();
                    const changesPercentage = data[0].changesPercentage.toFixed(2);
                    let formattedChangePercentage = changesPercentage > 0 ? `+${changesPercentage}%` : `${changesPercentage}%`;

                    const listItem = document.createElement('li');
                    listItem.textContent = `${data[0].symbol.slice(1)} ${formattedChangePercentage}`;
                    indexChangesList.appendChild(listItem);
                } catch (error) {
                    console.error("Error fetching data:", error);
                }
            }
        };

        async function fetchData() {
            checkTheme();
            await fetchIndex();
        };


        // FETCH STOCK DATA 
        // DO NOT FLATTEN THE DATA, KEEP IT AS AN LIST OF LIST OF OBJECTS
        // BECAUSE WE WANT TO KEEP THE DATA FOR EACH STOCK IN A SEPARATE LIST INSIDE THE stocks LIST
        async function fetchAndDisplayData() {
            const inputField = document.querySelector('.input-field');
            let ticker = inputField.value; // Get the latest ticker value
            if (!ticker) {
                console.error("No ticker entered.");
                return;
            }
            console.log('Fetching data for:', ticker);
            try {
                const incomeData = await fetchApiData(`v3/income-statement/${ticker}?period=annually`);
                const metricsData = await fetchApiData(`v3/key-metrics/${ticker}?period=annually`);
                const discountedCashFlow = await fetchApiData(`v4/advanced_discounted_cash_flow?symbol=${ticker}`);

                // foreach object in combined array, rename the keys to the swedish terms using the keyMapping object,
                // such that the values e.g. "Revenue" becomes "Intäkter" use the renameKeys function
                // but the value associated with the key "Currency" should remain "USD" but the key should be "Valuta"
                let combinedData = combineData(incomeData, metricsData, discountedCashFlow);
                console.log(combinedData);
                combinedData = combinedData.map(obj => renameKeys(obj)); // This now correctly renames keys

                // Keep only the latest 5 reports and adjust as per your logic
                let IncomeAndMetrics = combinedData.slice(0, 5);
                stocks.push(IncomeAndMetrics);
                console.log(stocks);
                redrawTables()

            } catch (error) {
                console.error("Error fetching data:", error);
            }
        }

        const combineData = (incomeData, metricsData, discountedCashFlow) => {
            const maxLength = Math.max(incomeData.length, metricsData.length, discountedCashFlow.length);
            return Array.from({ length: maxLength }, (_, i) => {
                const combinedObject = {
                    ...incomeData[i],
                    ...metricsData[i],
                    ...discountedCashFlow[i],
                };
                removeLastTwoKeyValues(combinedObject);
                return combinedObject;
            });
        };

        const fetchApiData = async (endpoint) => {
            try {
                const url = `https://financialmodelingprep.com/api/${endpoint}&apikey=${apikey}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json(); 
            } catch (error) {
                console.error("Error fetching data:", error);
                return [];
            }
        };

        function removeLastTwoKeyValues(obj) {
            const keys = Object.keys(obj);
            if (keys.length >= 2) {
                delete obj[keys[keys.length - 1]]; // Remove last key
                delete obj[keys[keys.length - 2]]; // Remove second last key
            }
        };
        const renameKeys = (object) => {
            const renamedObject = {};
            Object.entries(object).forEach(([key, value]) => {
                const swedishKey = keyMapping[key] || key; // Default to the original key if no translation is found
                renamedObject[swedishKey] = value;
            });
            return renamedObject;
        };

        /*
        #INFO FOR THE TABLE:
        - The stocks list is a list of list, each containing the latest 5 reports for a given stock.
            [ [report1, report2, report3, report4, report5], [report1, report2, report3, report4, report5], ... ],
        - Each report is an object containing the financial data for a given stock.
        
        TODO:
        - the table should have the the key metrics of the first object (report) in the right most column
            and the values for the latest report e.i the first object in the first list in the stocks list 
            in the column to the left of the key metrics column. 
            and report 2 to the left of report 1 and so on.
            so that we only display the key metrics once per table, and the latest report is always the first column.

        - If the stocks list is empty display some text that says "No data to display" or something similar.
        - Once the stocks list is updated, the tables should be redrawn to reflect the new data.
        - The table should be styled to look good and be responsive.
        
        #KEEP IN MIND: 
        - We are going to implement a filter function that filters the metrics based on the user input. (usere selects what metrics(rows) to be display)
        - The user should be able to set ranges for the metrics and the table should only display the stocks that meet the criteria.
        - User should be able to compair tables side by side. in the futures 


        */
        
        
        function redrawTables() {
            const stocksContainer = document.getElementById('stocksContainer');
            stocksContainer.innerHTML = ''; // Clear existing tables

            if (stocks.length === 0) {
                stocksContainer.textContent = 'No data to display';
                console.log('No data to display');
                return;
            }

            stocks.forEach(stockReports => {
                const tableContainer = document.createElement('div');
                tableContainer.className = 'stock-table-container';
                const table = createStockTable(stockReports.reverse()); // Reverse to ensure the latest report appears on the left
                if (table) { // Ensure the table exists before attempting to append
                    tableContainer.appendChild(table);
                    stocksContainer.appendChild(tableContainer);
                }
            });
        }

        function createStockTable(stockReports) {
            if (stockReports.length === 0) {
                console.error('Stock reports list is empty.');
                return null; // Return early if given an empty list of stock reports
            }

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            table.appendChild(thead);
            table.appendChild(tbody);

            // Assuming all reports have the same keys, we get keys from the first one
            const keys = Object.keys(stockReports[0]);

            // Header row creation
            const headerRow = document.createElement('tr');
            keys.forEach(key => {
                const th = document.createElement('th');
                th.textContent = key; // Could map to readable names if necessary
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // Constructing table body
            stockReports.forEach(report => {
                const row = document.createElement('tr');
                keys.forEach(key => {
                    const cell = document.createElement('td');
                    cell.textContent = report[key];
                    row.appendChild(cell);
                });
                tbody.appendChild(row);
            });

            return table;
        }

        // Listen to changes in the stocks array
        Object.defineProperty(window, 'stocks', {
            set: function (value) {
                stocks = value;
                console.log('Stocks array updated:', stocks);
                redrawTables(stocks);
            },
            get: function () {
                return stocks;
            }
        });



        
    </script>

    <style>
        :root {
            font-family: 'Segoe UI', 'Segoe UI Black', Roboto,
                Helvetica, Arial;
            background-color: #333;

        }

        body {
            margin: 0;
            background-color: var(--main-bg-color);
            color: var(--main-text-color);
        }

        /* Base styles for the light theme */
        :root {
            --main-bg-color: #f0f0f0;
            --main-text-color: #0b0c0d;
            --button-bg-color: #4CAF50;
            --button-text-color: #ffffff;
            --navbar-bg-color: #ffffff;
            --navbar-text-color: #333333;
            --button-hover-bg-color: #3d8e40;
            --button-hover-text-color: #3d8e40;

        }

        /* Dark theme overrides */
        [data-theme="dark"] {
            --main-bg-color: #1e2021;
            --main-text-color: #dfdcd8;
            --button-bg-color: #666;
            --button-text-color: #fff;
            --navbar-bg-color: #181a1b;
            --navbar-text-color: #ffffff;
            --button-hover-bg-color: #333333;
            --button-hover-text-color: #3d8e40;
        }

        * {
            overflow-x: hidden;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            max-width: 100vw;


        }

        .indexChanges>ul {
            display: flex;
            width: 40%;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
        }

        .indexChanges>ul>li {
            display: flex;
            margin: 8px;
            text-align: center;
            align-items: center;
            justify-content: center;

        }

        .indexChanges {
            display: flex;
            justify-content: center;
            align-items: center;

        }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: var(--navbar-bg-color);
            color: var(--navbar-text-color);

        }

        .nav-button {
            display: flex;
            gap: 20px;
            list-style: none;
            padding: 0;
            margin: 0;
            color: var(--navbar-text-color);
            margin-right: 5rem;
        }

        #theme-toggle {
            background-color: var(--bg-color);
            color: var(--text-color);
            border: none;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
            font-size: 32px;
            margin-left: 2rem;

        }

        #theme-toggle:hover {
            background-color: var(--main-bg-color);
            color: var(--main-text-color);
        }

        .fetch-con {
            margin-top: 3rem;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
        }

        .input-field {
            outline: none;
            height: 3rem;
            width: 15rem;
            border: 1px solid #727272;
            border-right: none;
            border-radius: 15px 0px 0px 15px;
            padding: 8px;
            font-size: 18px;
            background-color: var(--main-bg-color);
            color: var(--main-text-color);

        }

        .input-field:focus {
            outline: none;
            border: 1px solid #a8a8a8;
        }

        .fetch-btn {
            height: 3rem;
            width: 3rem;
            border-radius: 0;
            border: none;
            outline: none;
            background-color: #3a99ff;
            cursor: pointer;
            font-size: 22px;
        }

        .fetch-btn:hover {
            background-color: #3488e1;
        }

        .stock-table-container {
            margin-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        thead {
            background-color: #f2f2f2;
        }
    </style>
</body>

</html>